2.1.3 p.42
# 스프링 프레임워크
- 의존성 주입(DI : Dependency Injection)
- 제어의 역전(IoC : Inversion of Control)
의존성 주입은 디자인 패턴으로 IoC를 구현하는 방법 중 하나

의존성 주입이란 클래스가 의존하는 다른 클래스들을 외부에서 주입시킨다는 뜻

스프링 부트가 제공하는 다양한 어노테이션과 인터페이슬 이용하면 반복적으로 서블릿 클래스를 작성하지 않아도 됨.
1. HttpServlet 상속 받지 않아도 됨
2. doGet 메소드 override 하지않아도 됨
3. HttpServletRequest를 직접 파싱하지 않아도 되고
4. HttpServletResponse를 작성하지 않아도 된다.

위와 같은 장점을 활용하고자 스프링 프로젝트를 이용하는 것

@SpringBootApplication
: 이 어노테이션은 해당 클래스가 스프링 부트를 설정하는 클래스임을 의미
또 스프링은 @SpringBootApplication 어노테이션이 달린 클래스가 있는 패키지를 베이스 패키지로 간주

앞서 스프링의 중요 기능 중 하나가 의존성 주입 컨테이너로서의 기능이라고 했다.
스프링은 베이스 패키지와 그 하위 패키지에서 자바 빈을 찾아 스프링의 의존성 주입 컨테이너 오브젝트, 즉 ApplicationContext에 등록한다.
그리고 애플리케이션 실행 중 어떤 오브젝트가 필요한 경우 의존하는 다른 오브젝트를 찾아 연결해 준다.

자동으로 다른 오브젝트를 찾아 연결해주는 어노테이션 -> @Autowired

@service/@Controller/@Repository 어노테이션 내에는 @Component 어노테이션이 내장되어 Bean 등록이 가능함
@Component 어노테이션을 달기만하면 무조건 등록되는것이 아니라 @ComponentScan 어노테이션을 통해 스캔이 가능한데
@ComponentScan 어노테이션은 @SpringBootApplication이 이미 포함하고 있어 굳이 추가하지않아도 사용가능

즉 @Component 어노테이션을 통해 자동으로 Bean 등록을 할 수 있으며, @Autowired를 이용하면 오브젝트를 생성해줌

2.2.2 DTO p.90
# DTO 클래스의 목적(*)
서비스가 요청을 처리하고 클라이언트로 반환할 때 모델(model) 자체를 그대로 리턴하는 경우는 별로 없다.
보통은 데이터를 전달하는데 사용하는 오브젝트인 Data Transfer Object(DTO)로 변환해 리턴한다.

첫번째 이유는 비즈니스 로직을 캡슐화하기 위함이다. 모델은 데이터베이스 테이블 구조와 매우 유사하다. 
모델이 갖고 있는 필드들은 테이블의 스키마와 비슷할 확률이 높다. 대부분의 비즈니스는 외부인이 자사의 데이터베이스의 스키마를 아는 것을 원치 않는다.
이때 DTO처럼 다른 오브젝트로 바꿔 반환하면 외부 사용자에게 서비스 내부의 로직, 데이터베이스의 구조 등을 숨길 수 있다.

두번째 이유는 클라이언트가 필요한 정보를 모델이 전부 포함하지 않는 경우가 많기 때문이다. 가장 대표적인 예로 에러 메시지가 있다.
만약 서비스 실행 도중 사용자 에러가 나면 이 에러 메시지를 어디에 포함해야 하는가? 모델은 서비스 로직과는 관련이 없기 때문에 모델에 담기는 애매하다.
이런 경우 DTO에 에러 메시지 필드를 선언하고 DTO에 포함하면 된다.

2.2.3 REST API p.96
# REST
- REST는 Representational State Transfer의 약자로 아키텍처 스타일이다.
 아키텍처 스타일은 아키텍처 패턴과는 조금 다른데 아키텍처 패턴은 어떤 반복되는 문제 상황을 해결하는 도구이고, 아키텍처 스타일은 반복되는 아키텍처 디자인을 의미함

REST 아키텍처 스타일은 6가지 제약조건으로 구성된다.
6가지 제약조건을 따르는 API를 RESTful API 라고 한다.

REST 제약조건
 #### 클라이언트 - 서버 ( client-server )
 #### 상태가 없는 ( stateless )
 #### 캐시되는( cacheable ) 데이터
 #### 일관적인 인터페이스( Uniform Interface )
 #### 레이어 시스템 ( Layered System )
 #### 코드-온-디멘드 ( Code-On_Demend )(선택사항)
 
 ### 클라이언트-서버
 : 리소스(REST API가 리턴할 수 있는 모든것을 의미(HTML,JSON,이미지))를 
 관리하는 서버가 존재하고 다수의 클라이언트가 리소스를 소비하려고 네트워크를 통해 서버에 접근하는 구조를 의미한다.
 
 ### 상태가 없음
 : 상태가 없다는 것은 클라이언트가 서버에 요청을 보낼때 이전 요청의 영향을 받지않음을 의미한다.
 
 ### 캐시되는 데이터
 : 서버에서 리소스를 리턴할 떄 캐시가 가능한지 아닌지 명시할 수 있어야 한다.
 HTTP에서는 cache-control이라는 헤더에 리소스의 캐시 여부를 명시할 수 있다.
 
 ### 일관적인 인터페이스
 : 시스템 또는 애플리케이션의 리소스에 접근할 때 인터페이스가 일관적이어야 한다는 뜻
 
 ### 레이어 시스템
 : 클라이언트가 서버에 요청을 할 때 여러개 레이어로된 서버를 거칠 수 있다.
 예를 들어 서버가 인증 서버,캐시 서버, 로드 밸런서를 거쳐서 도착한다 가정할 때 이 사이의 레이어들은 요청과 응답에 어떤 영향을 미치지 않으며
 클라이언트는 서버의 레이어 존재 유무를 알지 못한다.
 
 ### 코드-온-디맨드
 이 제약은 선택 사항
 클라이언트는 서버에 코드를 요청할 수 있고 서버가 리턴한 코드를 실행할 수 있다.
 
 @requestMapping 말고 @GetMapping / @PostMapping / @PutMapping / @DeleteMapping 스프링 4.3버전 부터 지원
 사용할것!
 
 
 125P 
 # JPA
 Entity 클래스를 생성해서 테이블 이름을 지정하려면 @Table(name = "테이블명") 어노테이션을 추가해서 사용
 @Table을 추가하지않거나 name을 명시하지 않는다면 @Entity의 이름을 테이블 이름으로 간주.
 또 @Entity에 이름을 지정하지않는 경우 클래스의 이름을 테이블이름으로 간주
 
 @Id는 기본 키가 될 필드에 지정
 데이터베이스에 저장할 때마다 생성할수도 있지만 @GeneratedValue 어노테이션을 이용해 자동으로 생성 가능
 
 @GeneratedValue의 매개변수인 generator로 어떤 방식으로 ID를 생성할지 지정할 수 있다
 @genericGenerator는 Hibernate가 제공하는 기본 generator가 아니라 나만의 Generator를 사용하고 싶을 경우 이용
 이 Generator는 @GeneratedValue가 참조하여 사용
 
 spring 은 MethodInterceptor라는 AOP 인터페이스 사용 인터셉터에서 메서드의 이름을 확인하고 메서드의 이름을 기반으로 메소드 동작
 
 JPA / Spring JPA / hibernate
 
